# Pava
Run Java in Python

# Goals
Pava loads Java class files, decompiles the bytecodes, and emits Python source. This
allows Java code to be executed inside the Python VM.

Pava is a mirror of [Jython](http://www.jython.org/), with the difference that with
Pava, _Python_ is the dominant language, not _Java_.

Pava converts all the Java bytecodes, including the entire Java runtime in rt.jar,
caches the result, and allows the use of Java classes as if they were implemented in
Python directly.

# Example Hello World
Assuming we have a Java example looking like this:

    package helloworld
    
    public class HelloWorld {
        public static void main(String[] args) {
            System.out.println("Hello World!");
        }
    }
    
This Java code can be invoked unchanged using Pava as follows:

    import helloworld
    
    helloworld.HelloWorld.main__java_lang_String____()
    
This prints:

    Hello World!
    
Note the generated signature for the main function. It includes the type names
of all the arguments to support method overloading in the Java language.

Of course, the Python VM needs to be instructed where to find the Java class files.
This is done by informing pava of the classpath to use:

    import pava
    
    pava.set_classpath(['...the location of the Java classfiles...'])
    
# How does Pava work internally?

Pava execution happens in two phases. In the first phase, before anything really runs,
the Java classpath is processed and classfiles are transpiled. During this phase,
for each class file found on the classpath, Pava performs the following steps:

  * Load the class file
  * If needed, create a Python module with the same name as the Java package
  * Generate a Python class in the module
  * Add a Python method for each Java method found
  * Transpile each of the Java bytecodes into the corresponding Python source
  * Add a Python class attribute for each Java field found
  * Handle &lt;init&gt; and &lt;clinit&gt; to properly initialize the Python fields
  
During phase two, which is really during runtime execution of the code, nothing
special really happens:

  * The generated code, which is now regular Python code, is simply executed
  * The Java classloading behavior is mimicked by lazy loading of Python modules and classes
 
# Compilation of HelloWorld

Below is the resulting Python source for the HelloWorld Java program shown above. 
At the right side, the original Java bytecodes are shown:

    1. import java
    2.
    3. class HelloWorld(java.lang.Object):
    4.    def __java_init______(self):
    5.                                                    #    0 aload_0 
    6.        java.lang.Object.__java_init______(self)    #    1 invokespecial java.lang.Object.__java_init______()
    7.        return self                                 #    4 return 
    8.
    9.    @classmethod
    10.   def main__java_lang_String____(cls, a1):
    11.                                                   #    0 getstatic java.lang.System.out
    12.                                                   #    3 ldc Hello World
    13.       java.lang.System.out.println__java_lang_String__('Hello World')
    14.                                                   #    5 invokevirtual java.io.PrintStream.println__java_lang_String__(java.lang.String)
    15.       return None                                 #    8 return 


There are a number of noteworthy constructs in this generated Python code:

  - The `HelloWorld` class is a subclass of `java.lang.Object`. This relationship is
    preserved in the generated Python code as well.
  - The default contructor, generated by the Java compiler, is named `<init>`. That name
    is converted to `__java_init__` to generate a valid Python name. The name also includes
    a description of the method signature, in this case 4 underscores, representing a void
    method without arguments.
  - The `main` method at line 10 is declared as a static method in Java.
    This equates to a classmethod in Python. Its signature includes the argument
    types being an array of strings.
  - At line 13, a virtual method called `println` is invoked on a static field called `out`,
    declared by a class called `System`. In the Java source code, no package name is 
    given for `System`, as it is defined in the package `java.lang`.  In the generated
    Python code, packages become modules, classes are defined in a module, and methods are
    declared on a class the same way Python classes are.
  - Finally, the HelloWorld.main method is a void function. In other words, it does not return
    anything. In Python, however, all functions return a result, where the default return
    value is None. This means line 15 could be omitted in the Python code generation step.
    
# Next steps
Pava is in very early stage of development. Next steps are:

- Implement the few remaining bytecodes, such as multianewarray
- Implement do-while loops, which have complicated goto's in Python bytecodes
- Handle clinit to properly initialize static fields.
- Allow dynamic method lookup to support short names for overloaded Java methods.
- Write more tests for long/double/float/math operations.
- Run the test suite provided in the openjdk project.
